Git-commit: d72cad4597f9e7181e59fc304fa7bf482fe88eed
From: Yufen Wang <wangyufen@huawei.com>
Date: Wed, 20 Jan 2021 17:27:09 +0800
Subject: [PATCH] ARM: kdump: fix timer interrupts panic, could not boot
 capture_kernel
Patch-mainline: Queued in openEuler repo, version 5.10.0-3.0.0
References: openEuler-21.03
Git-repo: https://gitee.com/openeuler/kernel.git

hulk inclusion
category: bugfix
bugzilla: 47258
CVE: N/A

-------------------------------------------------

The kexec will boot a captured kernel while the kernel panic. But it boots
failed if the kernel panic in handler function of PPI. The reason is that
the PPI has not been 'eoi', other interrupts can not be handled when
booting the captured kernel. This patch fix this bug.

Signed-off-by: Yufen Wang <wangyufen@huawei.com>
Reviewed-by: Hanjun Guo <guohanjun@huawei.com>
Signed-off-by: zhangyi (F) <yi.zhang@huawei.com>

Conflicts:
	arch/arm/kernel/machine_kexec.c

Signed-off-by: Li Huafei <lihuafei1@huawei.com>
Reviewed-by: Wang Yufen <wangyufen@huawei.com>
Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Signed-off-by: Kai Liu <kai.liu@suse.com>
---
 arch/arm/kernel/machine_kexec.c | 18 ++++++++++++++++++
 1 file changed, 18 insertions(+)

diff --git a/arch/arm/kernel/machine_kexec.c b/arch/arm/kernel/machine_kexec.c
index 5d84ad333f05..78728051d51c 100644
--- a/arch/arm/kernel/machine_kexec.c
+++ b/arch/arm/kernel/machine_kexec.c
@@ -10,6 +10,7 @@
 #include <linux/io.h>
 #include <linux/irq.h>
 #include <linux/memblock.h>
+#include <linux/interrupt.h>
 #include <linux/of_fdt.h>
 #include <asm/mmu_context.h>
 #include <asm/cacheflush.h>
@@ -124,11 +125,28 @@ static void machine_kexec_mask_interrupts(void)
 
 	for_each_irq_desc(i, desc) {
 		struct irq_chip *chip;
+		int ret;
 
 		chip = irq_desc_get_chip(desc);
 		if (!chip)
 			continue;
 
+		/*
+		 * First try to remove the active state. If this
+		 * fails, try to EOI the interrupt.
+		 */
+		if (desc->irq_data.hwirq > 15 && desc->irq_data.hwirq < 32) {
+			bool active = false;
+			ret = irq_get_irqchip_state(i, IRQCHIP_STATE_ACTIVE, &active);
+			if (ret) {
+				pr_debug("Get irq active state failed.\n");
+			} else {
+				if (active)
+					chip->irq_eoi(&desc->irq_data);
+			}
+		}
+
+
 		if (chip->irq_eoi && irqd_irq_inprogress(&desc->irq_data))
 			chip->irq_eoi(&desc->irq_data);
 
-- 
2.31.1

