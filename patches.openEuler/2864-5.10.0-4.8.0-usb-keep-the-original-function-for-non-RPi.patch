Git-commit: a159876279c266ce44b3624cc66a86d06485bd64
From: Zheng Zengkai <zhengzengkai@huawei.com>
Date: Thu, 4 Mar 2021 21:16:23 +0800
Subject: [PATCH] usb: keep the original function for non-RPi
Patch-mainline: Queued in openEuler repo, version 5.10.0-4.8.0
References: openEuler-21.03
Git-repo: https://gitee.com/openeuler/kernel.git

raspberrypi inclusion
category: feature
bugzilla: 50432

------------------------------

This patch adjusts following usb related patches for
raspberry pi on non-Raspberry Pi platforms, using specific
config CONFIG_OPENEULER_RASPBERRYPI to distinguish them:

cbf9b5f6824e Add dwc_otg driver
470f92471f05 hid: Reduce default mouse polling interval to 60Hz
1771bca0cfd9 usb: xhci: Disable the XHCI 5 second timeout
fb2ea55232b4 usbhid: call usb_fixup_endpoint after mangling intervals
8f2c6b7c425a xhci: Use more event ring segment table entries

Signed-off-by: Zheng Zengkai <zhengzengkai@huawei.com>
Reviewed-by: Xie XiuQi <xiexiuqi@huawei.com>
Signed-off-by: Kai Liu <kai.liu@suse.com>
---
 arch/arm/include/asm/irqflags.h    | 15 +++++
 arch/arm/kernel/fiqasm.S           |  2 +
 drivers/hid/usbhid/hid-core.c      | 10 ++++
 drivers/usb/core/generic.c         |  2 +
 drivers/usb/core/hub.c             |  4 ++
 drivers/usb/core/message.c         |  2 +
 drivers/usb/core/otg_productlist.h | 96 +++++++++++++++++++++++++++---
 drivers/usb/host/xhci-mem.c        | 11 ++++
 drivers/usb/host/xhci.c            |  7 ++-
 drivers/usb/host/xhci.h            |  8 ++-
 10 files changed, 148 insertions(+), 9 deletions(-)

diff --git a/arch/arm/include/asm/irqflags.h b/arch/arm/include/asm/irqflags.h
index a3b186608c60..848974a3cf89 100644
--- a/arch/arm/include/asm/irqflags.h
+++ b/arch/arm/include/asm/irqflags.h
@@ -162,6 +162,7 @@ static inline unsigned long arch_local_save_flags(void)
 	return flags;
 }
 
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 /*
  * restore saved IRQ state
  */
@@ -184,6 +185,20 @@ static inline void arch_local_irq_restore(unsigned long flags)
 		: "r" (flags)
 		: "memory", "cc");
 }
+#else
+/*
+ * restore saved IRQ & FIQ state
+ */
+#define arch_local_irq_restore arch_local_irq_restore
+static inline void arch_local_irq_restore(unsigned long flags)
+{
+	asm volatile(
+		"	msr	" IRQMASK_REG_NAME_W ", %0	@ local_irq_restore"
+		:
+		: "r" (flags)
+		: "memory", "cc");
+}
+#endif
 
 #define arch_irqs_disabled_flags arch_irqs_disabled_flags
 static inline int arch_irqs_disabled_flags(unsigned long flags)
diff --git a/arch/arm/kernel/fiqasm.S b/arch/arm/kernel/fiqasm.S
index eef484756af2..c6a12bef0c9c 100644
--- a/arch/arm/kernel/fiqasm.S
+++ b/arch/arm/kernel/fiqasm.S
@@ -48,6 +48,8 @@ ENTRY(__get_fiq_regs)
 	ret	lr
 ENDPROC(__get_fiq_regs)
 
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 ENTRY(__FIQ_Branch)
 	mov pc, r8
 ENDPROC(__FIQ_Branch)
+#endif
diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c
index 3d5d82f7176f..ddb0a7e7400c 100644
--- a/drivers/hid/usbhid/hid-core.c
+++ b/drivers/hid/usbhid/hid-core.c
@@ -45,7 +45,11 @@
  * Module parameters.
  */
 
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 static unsigned int hid_mousepoll_interval = ~0;
+#else /* !CONFIG_OPENEULER_RASPBERRYPI */
+static unsigned int hid_mousepoll_interval;
+#endif
 module_param_named(mousepoll, hid_mousepoll_interval, uint, 0644);
 MODULE_PARM_DESC(mousepoll, "Polling interval of mice");
 
@@ -1114,9 +1118,13 @@ static int usbhid_start(struct hid_device *hid)
 		 */
 		switch (hid->collection->usage) {
 		case HID_GD_MOUSE:
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 			if (hid_mousepoll_interval == ~0 && interval < 16)
 				interval = 16;
 			else if (hid_mousepoll_interval != ~0 && hid_mousepoll_interval != 0)
+#else /* !CONFIG_OPENEULER_RASPBERRYPI */
+			if (hid_mousepoll_interval > 0)
+#endif
 				interval = hid_mousepoll_interval;
 			break;
 		case HID_GD_JOYSTICK:
@@ -1128,7 +1136,9 @@ static int usbhid_start(struct hid_device *hid)
 				interval = hid_kbpoll_interval;
 			break;
 		}
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 		usb_fixup_endpoint(dev, endpoint->bEndpointAddress, interval);
+#endif
 
 		ret = -ENOMEM;
 		if (usb_endpoint_dir_in(endpoint)) {
diff --git a/drivers/usb/core/generic.c b/drivers/usb/core/generic.c
index fe8c7a85e141..8865581c0da0 100644
--- a/drivers/usb/core/generic.c
+++ b/drivers/usb/core/generic.c
@@ -190,7 +190,9 @@ int usb_choose_configuration(struct usb_device *udev)
 		dev_warn(&udev->dev,
 			"no configuration chosen from %d choice%s\n",
 			num_configs, plural(num_configs));
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 		dev_warn(&udev->dev, "No support over %dmA\n", udev->bus_mA);
+#endif
 	}
 	return i;
 }
diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c
index b4b0bb640118..a5d576010826 100644
--- a/drivers/usb/core/hub.c
+++ b/drivers/usb/core/hub.c
@@ -5444,7 +5444,11 @@ static void port_event(struct usb_hub *hub, int port1)
 		port_dev->over_current_count++;
 		port_over_current_notify(port_dev);
 
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 		dev_notice(&port_dev->dev, "over-current change #%u\n",
+#else
+		dev_dbg(&port_dev->dev, "over-current change #%u\n",
+#endif
 			port_dev->over_current_count);
 		usb_clear_port_feature(hdev, port1,
 				USB_PORT_FEAT_C_OVER_CURRENT);
diff --git a/drivers/usb/core/message.c b/drivers/usb/core/message.c
index 6f0c19d76515..c0372aa7685e 100644
--- a/drivers/usb/core/message.c
+++ b/drivers/usb/core/message.c
@@ -2144,6 +2144,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 	if (cp->string == NULL &&
 			!(dev->quirks & USB_QUIRK_CONFIG_INTF_STRINGS))
 		cp->string = usb_cache_string(dev, cp->desc.iConfiguration);
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 /* Uncomment this define to enable the HS Electrical Test support */
 #define DWC_HS_ELECT_TST 1
 #ifdef DWC_HS_ELECT_TST
@@ -2223,6 +2224,7 @@ int usb_set_configuration(struct usb_device *dev, int configuration)
 			}
 		}
 #endif /* DWC_HS_ELECT_TST */
+#endif /* CONFIG_OPENEULER_RASPBERRYPI */
 
 	/* Now that the interfaces are installed, re-enable LPM. */
 	usb_unlocked_enable_lpm(dev);
diff --git a/drivers/usb/core/otg_productlist.h b/drivers/usb/core/otg_productlist.h
index b16e528859a8..0d0ef4c0d905 100644
--- a/drivers/usb/core/otg_productlist.h
+++ b/drivers/usb/core/otg_productlist.h
@@ -11,6 +11,8 @@
 static struct usb_device_id productlist_table[] = {
 
 /* hubs are optional in OTG, but very handy ... */
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
+
 #define CERT_WITHOUT_HUBS
 #if defined(CERT_WITHOUT_HUBS)
 { USB_DEVICE( 0x0000, 0x0000 ), }, /* Root HUB Only*/
@@ -20,27 +22,41 @@ static struct usb_device_id productlist_table[] = {
 { USB_DEVICE_INFO(USB_CLASS_HUB, 0, 2), },
 #endif
 
+#else /* !CONFIG_OPENEULER_RASPBERRYPI */
+{ USB_DEVICE_INFO(USB_CLASS_HUB, 0, 0), },
+{ USB_DEVICE_INFO(USB_CLASS_HUB, 0, 1), },
+#endif
+
 #ifdef	CONFIG_USB_PRINTER		/* ignoring nonstatic linkage! */
 /* FIXME actually, printers are NOT supposed to use device classes;
  * they're supposed to use interface classes...
  */
-//{ USB_DEVICE_INFO(7, 1, 1) },
-//{ USB_DEVICE_INFO(7, 1, 2) },
-//{ USB_DEVICE_INFO(7, 1, 3) },
+#ifndef CONFIG_OPENEULER_RASPBERRYPI
+{ USB_DEVICE_INFO(7, 1, 1) },
+{ USB_DEVICE_INFO(7, 1, 2) },
+{ USB_DEVICE_INFO(7, 1, 3) },
+#endif
 #endif
 
 #ifdef	CONFIG_USB_NET_CDCETHER
 /* Linux-USB CDC Ethernet gadget */
-//{ USB_DEVICE(0x0525, 0xa4a1), },
+#ifndef CONFIG_OPENEULER_RASPBERRYPI
+{ USB_DEVICE(0x0525, 0xa4a1), },
+#endif
 /* Linux-USB CDC Ethernet + RNDIS gadget */
-//{ USB_DEVICE(0x0525, 0xa4a2), },
+#ifndef CONFIG_OPENEULER_RASPBERRYPI
+{ USB_DEVICE(0x0525, 0xa4a2), },
+#endif
 #endif
 
 #if	IS_ENABLED(CONFIG_USB_TEST)
 /* gadget zero, for testing */
-//{ USB_DEVICE(0x0525, 0xa4a0), },
+#ifndef CONFIG_OPENEULER_RASPBERRYPI
+{ USB_DEVICE(0x0525, 0xa4a0), },
+#endif
 #endif
 
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 /* OPT Tester */
 { USB_DEVICE( 0x1a0a, 0x0101 ), }, /* TEST_SE0_NAK */
 { USB_DEVICE( 0x1a0a, 0x0102 ), }, /* Test_J */
@@ -69,10 +85,12 @@ static struct usb_device_id productlist_table[] = {
 /* Speakers */
 //{ USB_DEVICE( 0x0499, 0x3002 ), }, /* YAMAHA YST-MS35D USB Speakers */
 //{ USB_DEVICE( 0x0672, 0x1041 ), }, /* Labtec USB Headset */
+#endif
 
 { }	/* Terminating entry */
 };
 
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 static inline void report_errors(struct usb_device *dev)
 {
 	/* OTG MESSAGE: report errors here, customize to match your product */
@@ -85,8 +103,9 @@ static inline void report_errors(struct usb_device *dev)
                 dev_printk(KERN_CRIT, &dev->dev, "Attached Device is not Supported\n");
         }
 }
+#endif
 
-
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 static int is_targeted(struct usb_device *dev)
 {
 	struct usb_device_id	*id = productlist_table;
@@ -189,4 +208,67 @@ static int is_targeted(struct usb_device *dev)
 	report_errors(dev);
 	return 0;
 }
+#else /* !CONFIG_OPENEULER_RASPBERRYPI  */
+static int is_targeted(struct usb_device *dev)
+{
+	struct usb_device_id	*id = productlist_table;
+
+	/* HNP test device is _never_ targeted (see OTG spec 6.6.6) */
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a &&
+	     le16_to_cpu(dev->descriptor.idProduct) == 0xbadd))
+		return 0;
+
+	/* OTG PET device is always targeted (see OTG 2.0 ECN 6.4.2) */
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a &&
+	     le16_to_cpu(dev->descriptor.idProduct) == 0x0200))
+		return 1;
+
+	/* NOTE: can't use usb_match_id() since interface caches
+	 * aren't set up yet. this is cut/paste from that code.
+	 */
+	for (id = productlist_table; id->match_flags; id++) {
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_VENDOR) &&
+		    id->idVendor != le16_to_cpu(dev->descriptor.idVendor))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_PRODUCT) &&
+		    id->idProduct != le16_to_cpu(dev->descriptor.idProduct))
+			continue;
+
+		/* No need to test id->bcdDevice_lo != 0, since 0 is never
+		   greater than any unsigned number. */
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_LO) &&
+		    (id->bcdDevice_lo > le16_to_cpu(dev->descriptor.bcdDevice)))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_HI) &&
+		    (id->bcdDevice_hi < le16_to_cpu(dev->descriptor.bcdDevice)))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_CLASS) &&
+		    (id->bDeviceClass != dev->descriptor.bDeviceClass))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_SUBCLASS) &&
+		    (id->bDeviceSubClass != dev->descriptor.bDeviceSubClass))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_PROTOCOL) &&
+		    (id->bDeviceProtocol != dev->descriptor.bDeviceProtocol))
+			continue;
+
+		return 1;
+	}
+
+	/* add other match criteria here ... */
+
+
+	/* OTG MESSAGE: report errors here, customize to match your product */
+	dev_err(&dev->dev, "device v%04x p%04x is not supported\n",
+		le16_to_cpu(dev->descriptor.idVendor),
+		le16_to_cpu(dev->descriptor.idProduct));
+
+	return 0;
+}
+#endif
 
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 994e13c11a3a..f1e8c2d25126 100644
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -2512,11 +2512,18 @@ int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags)
 	 * Event ring setup: Allocate a normal ring, but also setup
 	 * the event ring segment table (ERST).  Section 4.9.3.
 	 */
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 	val2 = 1 << HCS_ERST_MAX(xhci->hcs_params2);
 	val2 = min_t(unsigned int, ERST_MAX_SEGS, val2);
+#endif
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init, "// Allocating event ring");
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 	xhci->event_ring = xhci_ring_alloc(xhci, val2, 1, TYPE_EVENT,
 					   0, flags);
+#else /* !CONFIG_OPENEULER_RASPBERRYPI */
+	xhci->event_ring = xhci_ring_alloc(xhci, ERST_NUM_SEGS, 1, TYPE_EVENT,
+			0, flags);
+#endif
 	if (!xhci->event_ring)
 		goto fail;
 	if (xhci_check_trb_in_td_math(xhci) < 0)
@@ -2529,7 +2536,11 @@ int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags)
 	/* set ERST count with the number of entries in the segment table */
 	val = readl(&xhci->ir_set->erst_size);
 	val &= ERST_SIZE_MASK;
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 	val |= val2;
+#else /* !CONFIG_OPENEULER_RASPBERRYPI */
+	val |= ERST_NUM_SEGS;
+#endif
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init,
 			"// Write ERST size = %i to ir_set 0 (some bits preserved)",
 			val);
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 393febe6a2bb..0cd45294428e 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -196,9 +196,14 @@ int xhci_reset(struct xhci_hcd *xhci)
 	if (xhci->quirks & XHCI_INTEL_HOST)
 		udelay(1000);
 
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
 	// Hack: reduce handshake timeout from 10s 0.5s due to unprogrammed vl805
 	ret = xhci_handshake(&xhci->op_regs->command,
-			CMD_RESET, 0, 500 * 1000);
+		CMD_RESET, 0, 500 * 1000);
+#else /* !CONFIG_OPENEULER_RASPBERRYPI */
+	ret = xhci_handshake(&xhci->op_regs->command,
+		CMD_RESET, 0, 10 * 1000 * 1000);
+#endif
 	if (ret)
 		return ret;
 
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
index 6bad1523500e..96b757389a99 100644
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -1649,8 +1649,14 @@ struct urb_priv {
  * Each segment table entry is 4*32bits long.  1K seems like an ok size:
  * (1K bytes * 8bytes/bit) / (4*32 bits) = 64 segment entries in the table,
  * meaning 64 ring segments.
- * Maximum number of segments in the ERST */
+ */
+#ifdef CONFIG_OPENEULER_RASPBERRYPI
+/* Maximum number of segments in the ERST */
 #define	ERST_MAX_SEGS	8
+#else /* !CONFIG_OPENEULER_RASPBERRYPI */
+/* Initial allocated size of the ERST, in number of entries */
+#define	ERST_NUM_SEGS	1
+#endif
 /* Initial allocated size of the ERST, in number of entries */
 #define	ERST_SIZE	64
 /* Initial number of event segment rings allocated */
-- 
2.31.1

